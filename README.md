# Python_files_and_context_managers
Домашняя работа по работе с файлами и контекстными менеджерами

# Задача
- В качестве практической работы необходимо нарисовать блок-схемы работы алгоритма решения задач и загрузить в свой репозиторий в течение дня.
- В качестве домашней работы необходимо реализовать программы по ранее созданным алгоритмам решения задач на языке Python и загрузить в свой репозиторий до крайнего срока.

Даты сдачи оговариваются в канале группы.

# Домашнее Задание
Создать классы Сериализации и Десериализации данных для каталога товаров:
* В качестве каталога товаров можно использовать класс карточки товара из предыдущего домашнего задания
* Данные должны считываться из файлов формата JSON/XML при их наличии, либо могут быть получены из файлов формата .txt или .excel
* Данные должны записываться в файлы формата JSON/XML и использоваться в рамках программы в качестве системы хранения данных
* При изменении карточки товара должна производиться перезапись данных в JSON/XML
* При добавлении новой карточки товара в JSON/XML должна добавиться новая запись
* При удалении карточки товара запись должна удаляться и из JSON/XML

# Практическое Задание
Нарисовать блок-схему взаимодействия с файлами, согласно заданию

# Теоретическая справка
**Файл** — это именованная область на носителе информации (диск, SSD и т.д.), предназначенная для хранения данных.
**Сериализация** - запись объектов в поток.
**Десериализация** - чтение объекта из потока.


### Что такое файл с точки зрения ОС?
Файл — это:
* Имя (например: data.txt)
* Путь (например: /home/user/data.txt)
* Содержимое (последовательность байтов)
* Метаданные:
  * размер
  * дата создания
  * права доступа
  * владелец

Операционная система управляет файлами через файловую систему.
Главное: файл — это просто последовательность байтов
Для компьютера:
* Файл = набор байтов
Не важно что хранится:
* текст
* картинка
* видео
* JSON
* XML
  
Всё хранится как байты.
Разница только в том, как мы интерпретируем эти байты.

## Процесс работы с файлами
1. Запрос на открытие
2. Получение дескриптора
3. Работа через буфер
4. Чтение / запись
5. Сброс буфера
6. Закрытие

### Открытие файла
Когда вы пишете:
```
f = open("data.txt", "r")
```
Происходит:
* Программа вызывает системный вызов ОС

ОС:
* Ищет файл в файловой системе
* Проверяет права доступа
* Проверяет режим (r/w/a)

Если всё успешно — ОС создаёт файловый дескриптор

### Что такое файловый дескриптор?
Файловый дескриптор — это числовой идентификатор открытого файла внутри операционной системы.

Python-объект f внутри содержит ссылку на этот дескриптор.

Это важно:
* ОС отслеживает все открытые файлы
* У процесса есть лимит открытых файлов

Если файл не закрывать — можно получить ошибку:
```
Too many open files
```

### Буферизация

Когда вы читаете или записываете файл, данные не всегда сразу идут на диск.

Используется буфер — область памяти, потому что:
* Доступ к диску медленный
* RAM очень быстрая

При записи:
#### Программа → Буфер (RAM) → Диск
Сначала данные попадают в буфер, а только потом — на диск.

### Когда буфер сбрасывается?
* Когда буфер заполняется
* При вызове flush()
* При закрытии файла
* Иногда автоматически

Пример:
```
f.write("Hello")
f.flush()  # принудительная сбрасывает запись на диск
```

### Чтение файла — что происходит?
Когда вы читаете файл:
```
data = f.read()
```
Происходит такой процесс:
#### Диск → Буфер ОС → Буфер Python → Переменная
Сначала данные читаются блоками в память, а затем передаются в программу.

#### Методы чтения из файла
* Метод .read(): Читает весь файл целиком.
* Метод .readline(): Читает одну строку.
* Метод .readlines(): Возвращает список строк.

Примеры:
```
# Чтение всего файла
with open('example.txt', 'r') as file:
    content = file.read()
print(content)

# Поочередное чтение строк
with open('example.txt', 'r') as file:
    for line in file:
        print(line.strip())
```

### Указатель позиции (file pointer)
У каждого открытого файла есть позиция чтения/записи.
Пример:
```
f.read(5)
```
Файл прочитает первые 5 байтов и указатель сдвинется вперёд.

Можно управлять позицией:
```
f.seek(0)   # перейти в начало
f.tell()    # узнать текущую позицию
```
Это особенно важно при работе с бинарными файлами.

### Что происходит при закрытии?
```
f.close()
```
ОС:
* Сбрасывает буфер
* Освобождает дескриптор
* Удаляет файл из списка открытых

Если не закрыть файл:
* Данные могут не записаться полностью
* Возможны утечки ресурсов

Для таких случаев используется менеджер контекста:
```
with open("file.txt") as f:
```

### Права доступа
Когда файл открывается:
* ОС проверяет права
* Если нет прав → исключение

### Режимы открытия — что реально меняется?
"r":
* Только чтение
* Указатель в начале

"w":
* Очищает файл
* Создаёт новый если нет

"a":
* Указатель в конце
* Данные только добавляются

"rb", "wb":
* Без преобразования кодировки
* Работа с байтами

### Что может пойти не так?
При работе с файлами возможны:
* FileNotFoundError
* PermissionError
* IsADirectoryError
* Disk full
* Corrupted file
* Encoding error

Поэтому используется:
```
try:
    ...
except Exception as e:
    print(e)
```

## Методы для работы с текстовыми файлами
### Чтение файла
* Метод .read(): Читает весь файл целиком.
* Метод .readline(): Читает одну строку.
* Метод .readlines(): Возвращает список строк.

Примеры:
```
# Чтение всего файла
with open('example.txt', 'r') as file:
    content = file.read()
print(content)

# Поочередное чтение строк
with open('example.txt', 'r') as file:
    for line in file:
        print(line.strip())
```

### Запись в текстовый файл
Запись в файлы осуществляется методом .write(). Этот метод принимает строку и записывает её в открытый файл.
```
# Перезапись файла
with open('output.txt', 'w') as file:
    file.write("Привет, мир!\n")

# Дописывание строки в конец файла
with open('output.txt', 'a') as file:
    file.write("Это вторая строка.\n")
```

## JSON
JSON (JavaScript Object Notation) — это легкий формат обмена данными, широко используемый для передачи структурированных данных между приложениями. Формат легко читается людьми и машинами, что делает его популярным выбором для веб-разработки, API-интерфейсов и хранения конфигураций.

Формат JSON основан на парах ключ-значение (key-value) и поддерживает три основных типа данных:

* Объекты (object): коллекции пар ключ-значение, заключённые в фигурные скобки {}.
* Массивы (array): упорядоченный список значений, заключённый в квадратные скобки [].
* Простые типы: строки (string), числа (number), булевые значения (true, false), null (null).

Пример простого JSON-документа:
```
{
  "name": "Иван",
  "age": 30,
  "isDeveloper": true,
  "skills": ["Python", "JavaScript"],
  "address": {
    "city": "Москва",
    "street": "Ленинградская улица, дом 12"
  }
}
```

### Чтение JSON-файлов

Для чтения содержимого JSON-файла используются специальные библиотеки и встроенные инструменты большинства современных языков программирования.

В Python работа с JSON осуществляется с помощью стандартной библиотеки json. Для чтения файла используется метод load() или loads(), если данные находятся в строке.
```
import json

# Открываем файл и загружаем данные
with open('data.json', 'r') as file:
    data = json.load(file)

print(data['name'])  # Выведет: Иван
```

### Запись в JSON-файлы

Запись данных в JSON также поддерживается большинством популярных языков программирования.

Метод dump() записывает объект в файл, а dumps() возвращает строковую версию JSON-данных.
```
import json

new_data = {"hobby": "Программирование"}

# Добавляем новые данные
with open('data.json', 'w') as file:
    json.dump(new_data, file, indent=4)
```

### Преимущества:
* Легко читаемый человеком формат.
* Широкая поддержка библиотеками всех популярных языков программирования.
* Удобен для передачи данных между клиентской частью и сервером.
* Поддерживает вложенность объектов и массивов.
### Недостатки:
* Отсутствует стандартизированная поддержка комментариев внутри файлов (хотя иногда встречаются нестандартные расширения).
* Ограниченная структура типов данных (например, отсутствуют собственные типы данных вроде дат).
### Применение JSON
* Конфигурационные файлы приложений.
* Хранение небольших объемов данных.
* Передача данных между клиентами и серверами.
* Локализация интерфейсов и настройка поведения программы.

## XML
XML (Extensible Markup Language) — расширяемый язык разметки, предназначенный для представления и хранения структурированной информации. Подобно HTML, XML состоит из элементов, атрибутов и текста, однако основное отличие заключается в том, что XML позволяет разработчикам создавать собственные структуры данных, определяемые собственными правилами и схемами.

### Структура XML-документов

Основные компоненты XML-документа включают:

* Корневой элемент: обязательный верхний уровень документа, содержащий всю остальную структуру.
* Элементы: контейнеры данных, состоящие из открывающего и закрывающего тегов, между которыми находится содержание элемента.
* Атрибуты: дополнительные свойства элементов, задаются в открывающем теге.
* Текстовые узлы: контент, находящийся непосредственно внутри элементов.

### Пример простого XML-документа:
```
<?xml version="1.0" encoding="UTF-8"?>
<library>
  <book id="1">
    <title>Война и мир</title>
    <author>Лев Толстой</author>
    <year>1869</year>
  </book>
  <book id="2">
    <title>Преступление и наказание</title>
    <author>Фёдор Достоевский</author>
    <year>1866</year>
  </book>
</library>
```
### Особенности XML
* Расширяемость: разработчики сами определяют элементы и структуру документов.
* Объявления DTD и схемы XSD: позволяют определить правила валидности документа.
* Поддержка пространства имен: помогает избежать конфликтов имен при смешивании разных XML-пространств.

### Чтение XML-файлов

Для обработки XML существуют специализированные библиотеки, позволяющие анализировать и извлекать необходимую информацию.

В Python для работы с XML часто используют библиотеку ElementTree или стороннюю библиотеку lxml.
```
from xml.etree import ElementTree as ET

tree = ET.parse("books.xml")
root = tree.getroot()

for book in root.findall("book"):
    title = book.find("title").text
    author = book.find("author").text
    print(f"{title}, Автор: {author}")
```

### Создание и запись XML-файлов

Также существует возможность динамически формировать XML-документы.

Использование ElementTree для создания XML-документа:
```
import xml.etree.ElementTree as ET

library = ET.Element("library")

book1 = ET.SubElement(library, "book", attrib={"id": "1"})
ET.SubElement(book1, "title").text = "Мастер и Маргарита"
ET.SubElement(book1, "author").text = "Михаил Булгаков"

tree = ET.ElementTree(library)
tree.write("output.xml")
```

### Когда использовать XML?
* Для описания сложных иерархических структур данных.
* В системах B2B (business-to-business), где важно обеспечить переносимость и совместимость данных.
* Если необходим строгий контроль над структурой и валидностью данных с помощью DTD или XSD.

## Что такое менеджер контекста?

Менеджер контекста — это объект, обеспечивающий автоматическое выполнение определенных действий при входе и выходе из специального блока кода. Чаще всего эта функциональность реализуется с использованием ключевого слова `with`.

Вот простой пример использования менеджера контекста для работы с файлом:

```python
with open('example.txt', 'r') as file:
    contents = file.read()
```

Здесь менеджер контекста представлен объектом, возвращаемым функцией `open()`. Когда интерпретатор входит внутрь блока `with`, файл открывается, а когда выходит — автоматически закрывается независимо от наличия ошибок.

## Как работают менеджеры контекста?

Механизм работы менеджеров контекста основан на двух специальных методах класса:

- `__enter__(self)`: Метод, вызываемый при входе в блок `with`. Обычно используется для инициализации ресурса (открытия файла, подключения к базе данных и т.п.).
- `__exit__(self, exc_type, exc_value, traceback)`: Метод, вызываемый при выходе из блока `with`. Здесь выполняется освобождение ресурса (закрытие файла, разрыв соединения и т.п.). Дополнительно этот метод получает аргументы исключения (если оно возникло), позволяя обрабатывать их прямо здесь.

Простой пример реализации собственного менеджера контекста:

```python
class ManagedFile:
    def __init__(self, filename):
        self.filename = filename

    def __enter__(self):
        # Открываем файл при входе в блок with
        self.file = open(self.filename, 'r')
        return self.file

    def __exit__(self, exc_type, exc_val, traceback):
        if self.file:
            # Закрываем файл при выходе из блока with
            self.file.close()

# Использование нашего менеджера контекста
with ManagedFile('example.txt') as f:
    print(f.read())
```

### Преимущества использования менеджеров контекста:

1. **Автоматизация управления ресурсами**:
   Менеджеры контекста гарантируют, что ресурс освобождается сразу же после выхода из блока, даже если возникла ошибка.
   
2. **Упрощение написания читаемого кода**:
   Вместо ручного открытия и закрытия файлов или соединений можно написать лаконичный и понятный код с минимальным количеством повторяющихся операций.

3. **Обработка исключений**:
   Даже если внутри блока возникнет исключение, менеджер контекста обеспечит правильное завершение обработки ресурса, предотвращая возможные проблемы с памятью или состоянием системы.

